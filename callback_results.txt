Epoch 0.16723438338922483:
Input: public void init(OutputStream out, int bufSize)
	{
		if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled()&&logger.isLoggable (Level.FINE)) {  //306998.15
			logger.logp(Level.FINE, CLASS_NAME,"init", "init", out);
        }
		// make sure that we don't have anything hanging around between

Output: 		// the stack and the stack
		out.write(buf);
	

Epoch 0.17603619304128929:
Input: public void marshall(AdminLinkProviderForUserRequest adminLinkProviderForUserRequest, ProtocolMarshaller protocolMarshaller) {

        if (adminLinkProviderForUserRequest == null) {
            throw new SdkClientException("Invalid argument passed to marshall(...)");
        }

        try {
            protocolMarshaller.marshall(adminLinkProviderForUserRequest.getUserPoolId(), USERPOOLID_BINDING);
            protocolMarshaller.marshall(adminLinkProviderForUserRequest.getDestinationUser(), DESTINATIONUSER_BINDING);
            protocolMars
Output:             protocolMarshaller.marshall(adminLinkProviderForUserRequest.getDestinationPassword(), DESTINATIONPASSWORD_

Epoch 0.18483800269335376:
Input: void writeSpan(Span span, int sizeOfSpan, Buffer result) {
    result.writeByte(SPAN.key);
    result.writeVarint(sizeOfSpan); 
Output:   }

Epoch 0.19363981234541822:
Input: public void householderSymmetric( int row , double gamma )
    {
        int startU = row*N;

        // compute v = -gamma*A*u
        for( int i = row+1; i < N; i++ ) {
            double totalReal = 0;
            double totalImag = 0;

            // the lower triangle is not written to so it needs to traverse upwards
            // to get the information.  Reduces the number of matrix writes need
            // improving large matrix performance
            for( int j = row+1; j < i; j++ ) {
                double realA = QT.data[(j*N+i)*2];
                double imagA = -QT.data[(j*N+i)*2+1];

                double realU = QT.data[(startU+j)*2];
                double imagU = QT.data[(startU+j)*2+1];

                totalReal += realA*realU - imagA*imagU;
                totalImag += realA*imagU + imagA*realU;
            }
            for( int j = i; j < N; j++ ) {
                double realA = QT.data[(i*N+j)*2];
                double imagA = QT.data[(i*N+j)*2+1];

                double realU = QT.data[(startU+j)*2];
                double imagU = QT.data[(startU+j)*2+1];

                totalReal += realA*realU - imagA*imagU;
                totalImag += realA*imagU + imagA*realU;
            }
            w[i*2]   = -gamma*totalReal;
            w[i*2+1] = -gamma*totalImag;
        }

        // alpha = -0.5*gamma*u^T*v
        double realAplha = 0;
        double imageAlpha = 0;

        for( int i = row+1; i < N; i++ ) {
            double realU = QT.data[(startU+i)*2];
            double imagU = -QT.data[(startU+i)*2+1];

            double realV = w[i*2];
            double imagV = w[i*2+1];

            realAplha += realU*realV - imagU*imagV;
            imageAlpha += realU*imagV + imagU*realV;
        }
        realAplha *= -0.5*gamma;
        imageAlpha *= -0.5*gamma;

        // w = v + alpha*u
        for( int i = row+1; i < N; i++ ) {
            double realU = QT.data[(startU+i)*2];
            double imagU = QT.data[(startU+i)*2+1];

            w[i*2]   += realAplha*realU - imageAlpha*imagU;
            w[i*2+1] += realAplha*imagU +
Output:             }

            double realAplha = -0.5*gamma*real

Epoch 0.2024416219974827:
Input: public static Application getApplicationFromClassPath(final String _application,
                                                          final List<String> _classpath)
        throws InstallationException
    {
        re
Output:         return getApplicationFromClassPath(_application, _classpath);
    }

Epoch 0.21124343164954715:
Input: @Override
    public BSONObject create(boolean array, List<String> pathParts) {
        if (rootClass == null) {
            return array ? new BasicDBList() : new BasicDBObject();
        }

        if (pathParts == null) {
            try {
                return (DBObject) rootClass.newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        String path = buildPath(pathParts);
        Class returnClass;

        if ((returnClass = getClassFromCache(path)) == null) {
            returnClass = deriveClass(path, pathParts.get(pathParts.size() - 1), array);
        }

        // At this point, we know what class to construct and the class cache is properly set

        if (DBObject.class.isAssignableFrom(returnClass)) {
            try {
                return (DBObject) returnClass.newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        } else if (Map.class.isAssignableFrom(returnClass)) {
            if (Modifier.isAbstract(returnClass.getModifiers()) || Modifier.isInterface(returnClass.getModifiers())) {
                return new DirtyableDBObjectMap();
            } else {
                try {
                    return new DirtyableDBObjectMap((Map) returnClass.newInstance());
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        } else if (List.class.isAssignableFrom(returnClass)) {
            if (Modifier.isAbstract(returnClass.getModifiers()) || Modifier.isInterface(returnClass.getModifiers())) {
                return new DirtyableDBObjectList();
            } else {
                try {
                    return new DirtyableDBObjectList((List) returnClass.newInstance(), false);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        } else if (Set.class.isAssignableFrom(returnClass)) {
            DirtyableDBObjectSet dirtyableDBObjectSet;

            if (Modifier.isAbstra
Output:             if (array && !array && !array && !array) {
                if (

Epoch 0.2200452413016116:
Input: private ResourceMethod computeMethod(ExecutableElement ee, List<ResourceArgument> arguments) {
    final String javaDoc = processingEnv.getElementUtils().getDocComment(ee);
    final Path pathAnnotation = ee.getAnnotation(Path.class);
    final Produces producesAnnotation = ee.getAnnotation(Produces.class);
    return new ResourceMethod(
        ee.getSimpleName().toString(),
        computeRequestMethod(ee),
        (pathAnnotation == null) ? null : pathAnno
Output:         javaDoc,
        (pathAnnotation == null) ? null : pathAnno.get

Epoch 0.22884705095367608:
Input: public static String termsStoreName(TableDefinition tableDef) {
        String objStoreName = Utils.truncateTo(objectsStoreName(tableDef), MAX_CF_NAME_LENGTH 
Output:         return objStoreName;
    }

Epoch 0.23764886060574053:
Input: public static Bitmap decodeStream(InputStream stream, boolean closeStream) {
        return AsyncBitmapTexture.decodeStream(stream,
                AsyncBitmapTexture.glMaxTextureSize,
   
Output:                 closeStream);
    }

Epoch 0.246450670257805:
Input: private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request, HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,
            ExecutionContext executionContext, URI cachedEndpoint, URI uriFromEndpointTrait) {

        executionContext.setCredentialsProvider(CredentialUtils.getCredentialsProvider(request.getOrigin
Output:                 .getCredentialsProvider(cachedEndpoint)),
                request.getCredentialsProvider(cached

Epoch 0.2552524799098695:
Input: @Override
  protected void flushAndSync(boolean durable) throws IOException {
    if (outputStream == null) {
      throw new IOException("Trying to use aborted output stream!");
    }
    if (doubleBuf.isFlushed()) {
      return;
    }
    // Under the covers, this invokes a method that does no
Output:     // for the same reason, we can do this.
    // This is a hack

Epoch 0.26405428956193394:
Input: public static Drawable getSelectableBackground(Context ctx) {
        int selectableBackgroundRes = getSelectableBackgroundRes(ctx);
        return
Output:             Drawable.fromInt(selectableBackgroundRes);
    }

Epoch 0.2728560992139984:
Input: public void rollback() {
        log.debug("Performing rollback");
        while (!operationExecutors.isEmpty()) {
            CompensatingTransactionOperationExecutor rollbackOperation = operationExecutors.pop();
            try {
                rollbackOperation.rollback();
            } catch (Exception e) {
       
Output:                 log.debug("Rollbacking transaction operation: " + rollbackOperation.getOperationName());

Epoch 0.28165790886606284:
Input: public static void retry(Predicate<Integer> action, String label, int times, long delay) throws TooManyRetriesException {
        if (times < 1) {
            throw new IllegalArgumentException("Retry block must try at least 1 time");
        }

        if (delay < 1) {
            throw new IllegalArgumentException("Must have at least 1 ms delay");
        }

        label = label == null ? "retry block" : label;

        int tries = 0;

        for (; times > tries; ++tries) {
            try {
                if (action.test(tries)) return;
            } catch (Exception e) {
                LOGGER.warn("Attempted to perform {}, but got exception", label, e);
            }

            try {
    
Output:             } catch (Exception e) {
                LOGGER.warn("Failed to perform {}, but

Epoch 0.29045971851812735:
Input: public ResourcePoolsBuilder withReplacing(ResourcePool resourcePool) {
    Map<ResourceType<?>, ResourcePool> newPools = new HashMap<>(resourcePools);
    newPools.put(resourcePoo
Output:         .getResourcePoolName(), resourcePool);
    return this;
  }

Epoch 0.2992615281701918:
Input: @Override
    public RejectCertificateTransferResult rejectCertificateTransfer(RejectCertificateTransferRequest request) {
        request = beforeClientExecution(re
Output:                 .resolveRequest(request);
    }

Epoch 0.30806333782225626:
Input: public static void setLearningRate(MultiLayerNetwork net, int layerNumber, ISchedule lrSchedule) {
        setLearningRate(
Output:                 new MultiLayerNetworkLearningRate(net, layerNumber, lrSchedule));
    }

Epoch 0.3168651474743207:
Input: public Access authorize(final AuthenticationResult authenticationResult)
  {
    transition(State.INITIALIZED, State.AUTHORIZING);
    return doAuthorize(
        authenticationResult,
        AuthorizationUtils.authorizeAllResourceActions(
            authenticationResult,
            Iterables.transform(
                baseQuery.getDataSo
Output:                 (AuthorizationResult.AUTHORIZATION_ID,
            AuthorizationUtils.authorizeAllResourceActions

Epoch 0.35207238608257857:
Input: @SuppressWarnings("unchecked")
	@Override
	public EList<IfcMaterialProfile> getMaterialProfiles() {
		return (EList<IfcMaterialProfile>) eGet(Ifc4Packa
Output: 				Ifc2x3tc1Package.Literals.IFC_MGR_

Epoch 0.4400904826032232:
Input: public void focusLost(FocusEvent _focusEvent) {
        short nFocusFlags = _focusEvent.FocusFlags;
        int nFocusChangeReason = nFocusFlags & FocusChangeReason.TAB;
        if (nFocusChangeReason == FocusChangeReason.TAB) {
            // get the window of the Window that has gained the Focus...
            // Note that the xWindow is just a representation of the controlwindow

Output:             _focusEvent.setFocus(nFocus);
        }
    }

Epoch 0.5281085791238679:
Input: public static void logComponent(final String type, final String details) {

    TransactionLogger instance = getInstan
Output:         (getInstance(type), details);
  }

Epoch 0.6161266756445125:
Input: private int processSet(String regex, int i, StringBuilder result, UnicodeSet temp, ParsePosition pos) {
        try {
            pos.setIndex(i);
            UnicodeSet x = temp.clear().applyPattern(regex, pos, symbolTable, 0);
            x.complement().complement(); // hack to fix toPattern
            result.append(x.toPattern(false));
            i = pos.getIndex() - 1; // allow for the loop increment
 
Output:             result.append(x.toPattern(true));
        } catch (Exception e

Epoch 0.7041447721651571:
Input: public Model enrichModel(Model model) {
        final List<BeanModel> dBeans = new ArrayList<>();
        final List<EnumModel> dEnums = new ArrayList<>();
        for (BeanModel bean : model.getBeans()) {
            final BeanModel dBean = enrichBean(bean);
            dBeans.add(dBean);
        }
        for (EnumModel enumModel : model.getEnums()) {
            final EnumM
Output:             final EnumModel enumModel = enrichEnum(enumModel);
            dEnums.

Epoch 0.7921628686858018:
Input: protected static void buildSignatureValidationFilterIfNeeded(final SamlRegisteredService service,
                                                                 final List<MetadataFilter> metadataFilterList,
                                                                 final Resource metadataSignatureResource) throws Exception {
        val signatureValidationFilter = SamlUtils.
Output:                 buildSignatureValidationFilterIfNeeded(service, metadataFilterList, metadataSignatureResource);
       

Epoch 0.8801809652064464:
Input: public static CommerceCurrency fetchByUUID_G(String uuid, long groupId,
		boolean retrieveFromCache) {
		return getPersistenc
Output: 				   .fetchByUUID_G(uuid, groupId, retrieveFromCache);
	}

Epoch 0.9681990617270911:
Input: @Override
	public Object getObject(final int columnIndex) throws SQLException {
		String columnLabel = getWrapped().getMetaData().getCol
Output: 				.getColumnLabel();
		return getObject(columnIndex, columnLabel);

